<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Queue TV Display</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link href="https://fonts.googleapis.com/css2?family=Battambang&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+Thai:wght@400;700&display=swap" rel="stylesheet">
    <style>
        * {
            box-sizing: border-box;
        }

        html {
            height: 100%;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: #1a1a1a;
            color: #f0f0f0;
            font-family: 'Noto Sans Thai', 'Battambang', Arial, sans-serif;
            display: flex;
            height: 100vh;
            width: 100vw;
            overflow: hidden;
        }

        .container {
            display: flex;
            width: 100%;
            flex-grow: 1;
        }

        .current-queue-station {
            flex: 0 0 40%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            border-right: 2px solid #333;
            padding: 1em;
            min-height: 0;
        }

        .label {
            font-size: 2.5vw;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 0.1em;
            animation: fadeIn 0.5s ease-in-out;
            text-align: center;
        }

        .subtitle {
            font-size: 1.5vw;
            font-weight: normal;
            margin-bottom: 0.5em;
            color: #bbb;
            animation: fadeIn 0.5s ease-in-out 0.2s;
            font-family: 'Battambang', Arial, sans-serif;
            text-align: center;
            line-height: 1.2;
        }

        .number-large {
            font-size: 8vw;
            font-weight: bold;
            color: #b19cd9;
            margin: 0.1em 0;
            animation: numberChange 0.8s ease-in-out;
            text-align: center;
            line-height: 1.1;
        }

        /* --- History Section Layout (Simplified) --- */
        .history-section {
            flex: 1;
            /* Takes remaining width */
            display: flex;
            /* Keep as flex container for table */
            flex-direction: column;
            /* Stack children (table) */
            overflow-y: auto;
            /* Scroll the WHOLE section */
            min-height: 0;
            /* Help flex sizing */
        }

        /* --- Table Layout (Simplified) --- */
        .history-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 2vw;
            text-align: center;
            /* Let table size itself naturally within history-section */
        }

        .history-table thead {
            /* Standard header group */
            background-color: #333;
            /* REMOVED: position: sticky; */
            /* REMOVED: top: 0; */
            /* REMOVED: z-index: 1; */
        }

        .history-table th {
            padding: 0.4em 0.8em;
            border-bottom: 1px solid #444;
            font-weight: 600;
            text-transform: uppercase;
        }

        .history-table td {
            padding: 0.4em 0.8em;
            border-bottom: 1px solid #333;
            word-break: break-all;
            animation: rowFadeIn 0.5s ease-in-out;
            /* Standard table cell display */
        }

        /* Row striping (standard table behaviour) */
        .history-table tbody tr:nth-child(even) {
            background-color: #2a2a2a;
        }

        /* Note: TD background is often preferred for full width color */
        .history-table tbody tr:nth-child(odd) {
            background-color: #222;
        }

        /* Media query (Simplified table layout needs less adjustment) */
        @media only screen and (max-width: 768px) {
            body {
                height: auto;
                min-height: 100vh;
            }

            .container {
                flex-direction: column;
                height: auto;
            }

            .current-queue-station {
                flex: 0 0 auto;
                border-right: none;
                border-bottom: 2px solid #333;
                padding: 2em 1em;
            }

            .history-section {
                flex: 1 1 auto;
                overflow-y: auto;
                min-height: 200px;
            }

            /* Ensure it scrolls */
            .label {
                font-size: 5vw;
            }

            .subtitle {
                font-size: 3vw;
            }

            .number-large {
                font-size: 15vw;
            }

            .history-table {
                font-size: 4vw;
            }
        }

        /* Keyframes (Unchanged) */
        @keyframes numberChange {
            from {
                opacity: 0.5;
                transform: scale(0.8);
            }

            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }

            to {
                opacity: 1;
            }
        }

        @keyframes rowFadeIn {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="current-queue-station">
            <div class="label">คิว/Queue</div>
            <div class="subtitle">(လိုင်း/Số thứ tự/បន្ទាត់/排队)</div>
            <div class="number-large" id="currentQueue">-</div>
            <div class="label" style="margin-top: 0.5em;">ช่อง/Station</div>
            <div class="subtitle">(ကောင်တာ/Quầy/ស្ថានីយ៍/窗口)</div>
            <div class="number-large" id="currentStation">-</div>
        </div>
        <div class="history-section">
            <table class="history-table">
                <thead>
                    <tr>
                        <th>คิว/Queue<br><span class="subtitle">(လိုင်း/Số thứ tự/បន្ទាត់/排队)</span></th>
                        <th>ช่อง/Station<br><span class="subtitle">(ကောင်တာ/Quầy/ស្ថានីយ៍/窗口)</span></th>
                    </tr>
                </thead>
                <tbody id="historyTable"></tbody>
            </table>
        </div>
    </div>

    <audio id="chimeAudio" src="chime.mp3" preload="auto"></audio>
    <audio id="ttsAudio" preload="none"></audio>

    <script>
        // DOM Elements & State Variables (Unchanged)
        const currentQueueEl = document.getElementById("currentQueue");
        const currentStationEl = document.getElementById("currentStation");
        const historyTableBody = document.getElementById("historyTable");
        const chimeAudio = document.getElementById("chimeAudio");
        const ttsAudio = document.getElementById("ttsAudio");
        let MAX_HISTORY = 10; // Default fallback
        let isPlayingTTS = false;
        const announcementQueue = [];
        const languagesToSpeak = ['th', 'en', 'vi', 'zh'];
        const RECONNECT_DELAY_MS = 5000;
        const HISTORY_RECALC_INTERVAL_MS = 30000;
        let socket;
        let reconnectTimeoutId = null;
        let historyRecalcIntervalId = null;

        // --- History Calculation (Reverted to Available Height Method) ---
        function calculateMaxHistory() {
            console.log("--- Running calculateMaxHistory (Simplified Layout Method) ---");
            try {
                const tableHeader = historyTableBody.previousElementSibling; // thead
                const historySection = historyTableBody.closest('.history-section'); // Use closest to be sure
                if (!historySection) {
                    console.error("Cannot find parent .history-section!");
                    MAX_HISTORY = 10; return; // Exit if container not found
                }
                const containerHeight = historySection.offsetHeight; // Height of .history-section
                const headerHeight = tableHeader ? tableHeader.offsetHeight : 0; // Height of the thead
                // Calculate available height *within* the history section, below the header
                const availableHeight = containerHeight - headerHeight;

                console.log(`[Calc] Container Height: ${containerHeight}, Header Height: ${headerHeight}, Available Height: ${availableHeight.toFixed(2)}`);

                if (availableHeight > 0) {
                    if (historyTableBody.children.length > 0) {
                        // --- Calculate based on existing rows ---
                        const firstRow = historyTableBody.children[0];
                        const rowHeight = firstRow.offsetHeight;
                        if (rowHeight > 0) {
                            // Calculate based on space BELOW the header
                            MAX_HISTORY = Math.max(1, Math.floor(availableHeight / rowHeight));
                            console.log(`[Calc Real Row] Row Height: ${rowHeight.toFixed(2)}, Calculated MAX_HISTORY: ${MAX_HISTORY}`);
                        } else {
                            console.warn(`[Calc Real Row] Fallback Trigger: Measured rowHeight is ${rowHeight}`);
                            MAX_HISTORY = 10;
                            console.log(`[Calc Real Row] Fallback MAX_HISTORY set to: ${MAX_HISTORY}`);
                        }
                    } else {
                        // --- Estimate based on styles if no rows exist ---
                        let tableFontSizeVw = 2;
                        if (window.matchMedia("only screen and (max-width: 768px)").matches) { tableFontSizeVw = 4; }
                        const baseFontSizePx = window.innerWidth * (tableFontSizeVw / 100);
                        const rowPaddingTopEm = 0.4; const rowPaddingBottomEm = 0.4;
                        const approxLineHeightFactor = 1.3; const borderBottomPx = 1;
                        const estimatedRowHeight = (rowPaddingTopEm * baseFontSizePx) + (rowPaddingBottomEm * baseFontSizePx) + (approxLineHeightFactor * baseFontSizePx) + borderBottomPx;
                        console.log(`[Estimation] Base Font Size (px): ${baseFontSizePx.toFixed(2)}, Estimated Row Height: ${estimatedRowHeight.toFixed(2)}`);
                        if (estimatedRowHeight > 0) {
                            // Estimate based on space BELOW the header
                            MAX_HISTORY = Math.max(1, Math.floor(availableHeight / estimatedRowHeight));
                            console.log(`Estimated MAX_HISTORY (no rows): ${MAX_HISTORY}`);
                        } else {
                            console.warn(`[Estimation] Fallback Trigger: Estimated rowHeight is ${estimatedRowHeight.toFixed(2)}`);
                            MAX_HISTORY = 10;
                            console.log(`Using fallback MAX_HISTORY (estimation failed): ${MAX_HISTORY}`);
                        }
                    }
                } else {
                    // Fallback if availableHeight is zero or negative
                    console.warn(`Fallback Trigger: availableHeight is ${availableHeight.toFixed(2)}`);
                    MAX_HISTORY = 10;
                    console.log(`Using fallback MAX_HISTORY (availableHeight <= 0): ${MAX_HISTORY}`);
                }

                trimHistory();

            } catch (error) {
                console.error("Error during calculateMaxHistory:", error);
                console.warn("Fallback Trigger: Caught error in calculation.");
                MAX_HISTORY = 10;
                console.log(`Using fallback MAX_HISTORY (error caught): ${MAX_HISTORY}`);
            }
            console.log("--- Finished calculateMaxHistory ---");
        }

        // --- Other Functions (trimHistory, connectEventSource, updateDisplay, TTS, Initialization) ---

        function trimHistory() {
            while (historyTableBody.children.length > MAX_HISTORY) {
                historyTableBody.removeChild(historyTableBody.lastChild);
            }
        }

        function connectEventSource() {
            if (reconnectTimeoutId) { clearTimeout(reconnectTimeoutId); reconnectTimeoutId = null; }
            if (socket) { socket.close(); }
            console.log("Attempting to connect to SSE endpoint...");
            socket = new EventSource("/events");
            socket.onopen = function () { console.log("SSE connection established."); };
            socket.onmessage = function (event) {
                try {
                    if (event.data.startsWith(': heartbeat')) { return; }
                    const { queue, station } = JSON.parse(event.data);
                    updateDisplay(queue, station);
                    announcementQueue.push({ queue, station });
                    playNextAnnouncement();
                } catch (error) { console.error("Error processing SSE message:", error, "Data:", event.data); }
            };
            socket.onerror = function (error) {
                console.error("SSE connection error:", error);
                socket.close();
                if (!reconnectTimeoutId) {
                    console.log(`Scheduling SSE reconnection attempt in ${RECONNECT_DELAY_MS / 1000} seconds...`);
                    reconnectTimeoutId = setTimeout(connectEventSource, RECONNECT_DELAY_MS);
                }
            };
        }

        function updateDisplay(queue, station) {
            const rows = historyTableBody.getElementsByTagName("tr");
            for (let i = rows.length - 1; i >= 0; i--) {
                const cells = rows[i].getElementsByTagName("td");
                if (cells.length > 0 && cells[0].textContent === String(queue)) {
                    historyTableBody.removeChild(rows[i]); break;
                }
            }
            currentQueueEl.textContent = queue;
            currentStationEl.textContent = station;
            currentQueueEl.style.animation = 'none'; currentQueueEl.offsetHeight; currentQueueEl.style.animation = null;
            currentStationEl.style.animation = 'none'; currentStationEl.offsetHeight; currentStationEl.style.animation = null;

            const row = document.createElement("tr");
            // REMOVED: Inline styles for display: table / table-cell
            row.innerHTML = `<td>${queue}</td><td>${station}</td>`;
            historyTableBody.insertBefore(row, historyTableBody.firstChild);
            trimHistory();
        }

        function playNextAnnouncement() {
            if (isPlayingTTS || announcementQueue.length === 0) { return; }
            isPlayingTTS = true;
            const { queue, station } = announcementQueue.shift();
            chimeAudio.currentTime = 0;
            chimeAudio.play()
                .then(() => {
                    chimeAudio.onended = () => {
                        playLanguagesSequentially(queue, station, 0);
                        chimeAudio.onended = null;
                    };
                })
                .catch(err => {
                    console.warn("Chime playback failed:", err, "- proceeding with TTS.");
                    setTimeout(() => playLanguagesSequentially(queue, station, 0), 200);
                });
        }

        function playLanguagesSequentially(queue, station, langIndex) {
            if (langIndex >= languagesToSpeak.length) {
                isPlayingTTS = false;
                setTimeout(playNextAnnouncement, 500);
                return;
            }
            const lang = languagesToSpeak[langIndex];
            const ttsUrl = `/speak?queue=${encodeURIComponent(queue)}&station=${encodeURIComponent(station)}&lang=${lang}`;
            ttsAudio.src = ttsUrl;
            ttsAudio.load();
            const playPromise = ttsAudio.play();
            if (playPromise !== undefined) {
                playPromise.then(() => {
                    ttsAudio.onended = () => {
                        ttsAudio.onended = null;
                        setTimeout(() => playLanguagesSequentially(queue, station, langIndex + 1), 100);
                    };
                }).catch(error => {
                    console.error(`Error playing ${lang} TTS for ${queue}/${station}:`, error);
                    ttsAudio.onended = null;
                    setTimeout(() => playLanguagesSequentially(queue, station, langIndex + 1), 100);
                });
            }
        }
        ttsAudio.onerror = (e) => {
            console.error("General TTS Audio Element Error (likely network/source issue):", e);
        };

        window.addEventListener('load', () => {
            setTimeout(calculateMaxHistory, 250); // Initial calc
            if (historyRecalcIntervalId) clearInterval(historyRecalcIntervalId);
            historyRecalcIntervalId = setInterval(calculateMaxHistory, HISTORY_RECALC_INTERVAL_MS);
            console.log(`Started periodic history recalculation every ${HISTORY_RECALC_INTERVAL_MS / 1000} seconds.`);
            connectEventSource(); // Start SSE
        });
        window.addEventListener('resize', calculateMaxHistory);
        window.addEventListener('beforeunload', () => {
            if (socket) socket.close();
            if (reconnectTimeoutId) clearTimeout(reconnectTimeoutId);
            if (historyRecalcIntervalId) clearInterval(historyRecalcIntervalId);
        });

    </script>
</body>

</html>