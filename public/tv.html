<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Queue TV Display</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link href="https://fonts.googleapis.com/css2?family=Battambang&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+Thai:wght@400;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@400;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">
    <style>
        /* CSS Styles */
        * {
            box-sizing: border-box;
        }

        html {
            height: 100%;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: #1a1a1a;
            color: #f0f0f0;
            /* Font stack for multi-language support */
            font-family: 'Noto Sans Thai', 'Noto Sans SC', 'Noto Sans JP', 'Roboto', 'Battambang', Arial, sans-serif;
            display: flex;
            height: 100vh;
            width: 100vw;
            overflow: hidden;
        }

        .container {
            display: flex;
            width: 100%;
            flex-grow: 1;
        }

        .current-queue-station {
            flex: 0 0 40%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            border-right: 2px solid #333;
            padding: 1em;
            min-height: 0;
        }

        .label {
            font-size: 2.5vw;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 0.1em;
            animation: fadeIn 0.5s ease-in-out;
            text-align: center;
        }

        .subtitle {
            font-size: 1.5vw;
            font-weight: normal;
            margin-bottom: 0.5em;
            color: #bbb;
            animation: fadeIn 0.5s ease-in-out 0.2s;
            font-family: 'Roboto', 'Battambang', Arial, sans-serif;
            /* Separate font for subtitles if needed */
            text-align: center;
            line-height: 1.2;
        }

        .number-large {
            font-size: 12vw;
            font-weight: bold;
            color: #b19cd9;
            margin: 0.1em 0;
            animation: numberChange 0.8s ease-in-out;
            text-align: center;
            line-height: 1.1;
        }

        .history-section {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
            min-height: 0;
        }

        .history-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 2vw;
            text-align: center;
        }

        .history-table thead {
            background-color: #333;
            position: sticky;
            top: 0;
            z-index: 1;
        }

        .history-table th {
            padding: 0.4em 0.8em;
            border-bottom: 1px solid #444;
            font-weight: 600;
            text-transform: uppercase;
        }

        .history-table td {
            padding: 0.4em 0.8em;
            border-bottom: 1px solid #333;
            word-break: break-all;
            animation: rowFadeIn 0.5s ease-in-out;
        }

        .history-table tbody tr:nth-child(even) {
            background-color: #2a2a2a;
        }

        .history-table tbody tr:nth-child(odd) {
            background-color: #222;
        }

        /* Responsive adjustments */
        @media only screen and (max-width: 768px) {
            body {
                height: auto;
                min-height: 100vh;
            }

            .container {
                flex-direction: column;
                height: auto;
            }

            .current-queue-station {
                flex: 0 0 auto;
                border-right: none;
                border-bottom: 2px solid #333;
                padding: 2em 1em;
            }

            .history-section {
                flex: 1 1 auto;
                overflow-y: auto;
                min-height: 200px;
                max-height: 50vh;
            }

            .label {
                font-size: 5vw;
            }

            .subtitle {
                font-size: 3vw;
            }

            .number-large {
                font-size: 15vw;
            }

            .history-table {
                font-size: 4vw;
            }

            .history-table thead {
                position: static;
            }
        }

        /* Animations */
        @keyframes numberChange {
            from {
                opacity: 0.5;
                transform: scale(0.8);
            }

            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }

            to {
                opacity: 1;
            }
        }

        @keyframes rowFadeIn {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="current-queue-station">
            <div class="label">คิว/Queue</div>
            <div class="subtitle">(လိုင်း/Số/Pila/番号/排队)</div>
            <div class="number-large" id="currentQueue">-</div>
            <div class="label" style="margin-top: 0.5em;">ช่อง/Station</div>
            <div class="subtitle">(ကောင်တာ/Quầy/Estasyon/窓口/窗口)</div>
            <div class="number-large" id="currentStation">-</div>
        </div>
        <div class="history-section">
            <table class="history-table">
                <thead>
                    <tr>
                        <th>คิว/Queue<br><span class="subtitle">(လိုင်း/Số/Pila/番号/排队)</span></th>
                        <th>ช่อง/Station<br><span class="subtitle">(ကောင်တာ/Quầy/Estasyon/窓口/窗口)</span></th>
                    </tr>
                </thead>
                <tbody id="historyTable"></tbody>
            </table>
        </div>
    </div>

    <audio id="chimeAudio" src="media/chime.mp3" preload="auto"></audio>
    <audio id="announcementAudio" preload="none"></audio>

    <script>
        // DOM Elements
        const currentQueueEl = document.getElementById("currentQueue");
        const currentStationEl = document.getElementById("currentStation");
        const historyTableBody = document.getElementById("historyTable");
        const chimeAudio = document.getElementById("chimeAudio");
        const announcementAudio = document.getElementById("announcementAudio");

        // State Variables
        let MAX_HISTORY = 10; // Max rows in history table
        let isPlayingAudio = false; // <<< Global lock to prevent audio overlap
        const announcementQueue = []; // FIFO queue for audio events {type: 'queue'|'public_cycle', data?: {...}}
        // Language sequence for individual queue calls
        const languagesToSpeak = ['th', 'en', 'my', 'vi', 'cn', 'ja'];
        // Language sequence for the periodic public announcement cycle
        const publicAnnouncementLanguages = ['th', 'en', 'my', 'vi', 'cn', 'ja'];
        const RECONNECT_DELAY_MS = 5000; // SSE reconnect delay
        const HISTORY_RECALC_INTERVAL_MS = 30000; // How often to recalculate history size
        let socket; // Holds the EventSource object
        let reconnectTimeoutId = null; // Timer ID for SSE reconnection
        let historyRecalcIntervalId = null; // Timer ID for history recalculation

        // --- History Table Size Calculation & Trimming ---
        function calculateMaxHistory() {
            // console.log("--- Running calculateMaxHistory ---");
            try {
                const tableHeader = historyTableBody.previousElementSibling; // thead
                const historySection = historyTableBody.closest('.history-section');
                if (!historySection) { console.error("Cannot find parent .history-section!"); MAX_HISTORY = 10; return; }
                const containerHeight = historySection.offsetHeight;
                const headerHeight = tableHeader ? tableHeader.offsetHeight : 0;
                const availableHeight = containerHeight - headerHeight;
                // console.log(`[Calc] Container: ${containerHeight}, Header: ${headerHeight}, Available: ${availableHeight.toFixed(2)}`);
                if (availableHeight <= 0) { MAX_HISTORY = 10; trimHistory(); return; }
                if (historyTableBody.children.length > 0) {
                    const firstRow = historyTableBody.children[0]; const rowHeight = firstRow.offsetHeight;
                    if (rowHeight > 0) { MAX_HISTORY = Math.max(1, Math.floor(availableHeight / rowHeight)); } else { MAX_HISTORY = 10; }
                } else {
                    let tableFontSizeVw = 2; if (window.matchMedia("only screen and (max-width: 768px)").matches) tableFontSizeVw = 4;
                    const baseFontSizePx = window.innerWidth * (tableFontSizeVw / 100); const rowPaddingTopEm = 0.4; const rowPaddingBottomEm = 0.4;
                    const approxLineHeightFactor = 1.3; const borderBottomPx = 1; const estimatedRowHeight = (rowPaddingTopEm * baseFontSizePx) + (rowPaddingBottomEm * baseFontSizePx) + (approxLineHeightFactor * baseFontSizePx) + borderBottomPx;
                    if (estimatedRowHeight > 0) { MAX_HISTORY = Math.max(1, Math.floor(availableHeight / estimatedRowHeight)); } else { MAX_HISTORY = 10; }
                }
                trimHistory();
            } catch (error) { console.error("Error during calculateMaxHistory:", error); MAX_HISTORY = 10; }
            // console.log(`--- Current MAX_HISTORY = ${MAX_HISTORY} ---`);
        }
        function trimHistory() {
            while (historyTableBody.children.length > MAX_HISTORY) {
                historyTableBody.removeChild(historyTableBody.lastChild);
            }
        }


        // --- Server-Sent Events (SSE) Connection ---
        function connectEventSource() {
            if (reconnectTimeoutId) { clearTimeout(reconnectTimeoutId); reconnectTimeoutId = null; }
            if (socket) { socket.close(); }
            console.log("Attempting to connect to SSE endpoint (/events)...");
            socket = new EventSource("/events"); // Server endpoint for events

            socket.onopen = function () { console.log("SSE connection established."); };

            socket.onmessage = function (event) {
                try {
                    // Ignore heartbeat messages
                    if (event.data.startsWith(': heartbeat')) { return; }

                    const data = JSON.parse(event.data);
                    console.log("SSE Received Data:", data);

                    // Handle specific event types from the server
                    if (data.type === 'public_announcement_cycle_start') {
                        console.log("SSE Received: Public Announcement Cycle Trigger");
                        announcementQueue.push({ type: 'public_cycle' });
                        playNextAnnouncement(); // Check if we can start playing now

                    } else if (data.type === 'queue_call' && data.data && data.data.queue && data.data.station) {
                        const { queue, station } = data.data;
                        console.log(`SSE Received: Queue Call ${queue} / ${station}`);
                        updateDisplay(queue, station); // Update visual display
                        announcementQueue.push({ type: 'queue', data: { queue: queue, station: station } });
                        playNextAnnouncement(); // Check if we can start playing now

                    } else {
                        console.warn("Received unknown or incomplete SSE message format:", data);
                    }
                } catch (error) {
                    console.error("Error processing SSE message:", error, "Raw Data:", event.data);
                }
            };

            socket.onerror = function (error) {
                console.error("SSE connection error:", error);
                socket.close();
                // Attempt to reconnect after a delay
                if (!reconnectTimeoutId) {
                    console.log(`Scheduling SSE reconnection attempt in ${RECONNECT_DELAY_MS / 1000} seconds...`);
                    reconnectTimeoutId = setTimeout(connectEventSource, RECONNECT_DELAY_MS);
                }
            };
        }

        // --- Update Visual Display ---
        function updateDisplay(queue, station) {
            const queueStr = String(queue); const stationStr = String(station);
            // Update large display numbers
            currentQueueEl.textContent = queueStr;
            currentStationEl.textContent = stationStr;
            // Re-trigger animations
            currentQueueEl.style.animation = 'none'; currentQueueEl.offsetHeight; currentQueueEl.style.animation = null;
            currentStationEl.style.animation = 'none'; currentStationEl.offsetHeight; currentStationEl.style.animation = null;

            // Add to history table if it's not the same as the last call
            const firstRow = historyTableBody.firstChild;
            if (!firstRow || firstRow.cells[0].textContent !== queueStr || firstRow.cells[1].textContent !== stationStr) {
                const row = document.createElement("tr");
                row.innerHTML = `<td>${queueStr}</td><td>${stationStr}</td>`;
                historyTableBody.insertBefore(row, historyTableBody.firstChild);
                trimHistory(); // Remove oldest rows if history exceeds max size
            }
        }


        // --- Core Announcement Playback Logic ---

        /**
         * Checks if audio is idle and if there are announcements in the queue.
         * If both conditions are met, it takes the next item, acquires the audio lock (isPlayingAudio=true),
         * plays a chime, and then delegates to the appropriate sequential playback function.
         */
        function playNextAnnouncement() {
            // **Strict Check:** Only proceed if nothing is playing AND queue is not empty
            if (isPlayingAudio || announcementQueue.length === 0) {
                console.log(`playNextAnnouncement: Bypassed (isPlayingAudio=${isPlayingAudio}, queueLength=${announcementQueue.length})`);
                return;
            }

            // **Acquire Lock & Dequeue:** Get item and set flag
            isPlayingAudio = true;
            const announcement = announcementQueue.shift();
            console.log(`playNextAnnouncement: Starting Processing. Set isPlayingAudio=true. Item: ${announcement.type}. Queue length: ${announcementQueue.length}`);

            // Play chime first (optional, can be removed if not desired)
            chimeAudio.currentTime = 0;
            const chimePromise = chimeAudio.play().catch(err => { console.warn("Chime playback failed:", err); return new Promise(resolve => setTimeout(resolve, 100)); /* Continue anyway */ });

            chimePromise.then(() => {
                const playAfterChime = () => {
                    chimeAudio.onended = null; // Cleanup listener
                    console.log(`playNextAnnouncement: Chime finished/skipped. Delegating item type: ${announcement.type}`);

                    // Delegate to the appropriate sequence player
                    if (announcement.type === 'queue') {
                        playQueueLanguagesSequentially(announcement.data, 0); // Start queue call sequence
                    } else if (announcement.type === 'public_cycle') {
                        playPublicCycleSequentially(0); // Start public announcement cycle sequence
                    } else {
                        console.error("Unknown announcement type processed:", announcement);
                        // **Release Lock** immediately if type is unknown to prevent deadlock
                        console.log("!!! Releasing lock due to unknown type !!!");
                        isPlayingAudio = false;
                        setTimeout(playNextAnnouncement, 100); // Check queue again quickly
                    }
                };
                // Ensure chime completion triggers the next step
                chimeAudio.onended = playAfterChime;
                if (chimeAudio.paused || chimeAudio.ended) { // If chime finished instantly or failed
                    playAfterChime();
                }
            });
        }

        /**
         * Plays the multi-language announcement for a single queue call sequentially.
         * Manages the isPlayingAudio lock for the duration of its sequence.
         * @param {object} queueData - { queue: string, station: string }
         * @param {number} langIndex - Current index in the languagesToSpeak array
         */
        function playQueueLanguagesSequentially(queueData, langIndex) {
            const { queue, station } = queueData;

            // **Base Case: Sequence Finished**
            if (langIndex >= languagesToSpeak.length) {
                console.log(`<- Finished QUEUE sequence for ${queue}/${station}. Releasing lock.`);
                // **Release Lock** for this entire sequence
                isPlayingAudio = false;
                // Check the main queue for the next item after a short delay
                setTimeout(playNextAnnouncement, 500);
                return; // End the sequence
            }

            // **Recursive Step: Play current language audio**
            const lang = languagesToSpeak[langIndex];
            // URL points to the server endpoint that generates TTS or serves fallback
            const audioUrl = `/speak?queue=${encodeURIComponent(queue)}&station=${encodeURIComponent(station)}&lang=${encodeURIComponent(lang)}`;
            console.log(`-> Playing QUEUE audio part ${langIndex + 1}/${languagesToSpeak.length}: ${lang} for ${queue}/${station}`);

            // Use the generic player; the lock remains TRUE until the base case above
            playAudioFromUrl(audioUrl,
                () => { // onEndCallback (Success): Called when this language finishes
                    console.log(`<- Finished QUEUE part OK: ${lang}.`);
                    playQueueLanguagesSequentially(queueData, langIndex + 1); // Play next language
                },
                () => { // onErrorCallback: Called when this language fails
                    console.error(`<- Finished QUEUE part ERROR: ${lang}. Skipping to next language.`);
                    playQueueLanguagesSequentially(queueData, langIndex + 1); // Try next language anyway
                }
            );
        }

        /**
         * Plays the full cycle of public announcements sequentially.
         * Manages the isPlayingAudio lock for the duration of its sequence.
         * @param {number} langIndex - Current index in the publicAnnouncementLanguages array
         */
        function playPublicCycleSequentially(langIndex) {
            // **Base Case: Sequence Finished**
            if (langIndex >= publicAnnouncementLanguages.length) {
                console.log("<- Finished PUBLIC announcement cycle sequence. Releasing lock.");
                // **Release Lock** for this entire sequence
                isPlayingAudio = false;
                // Check the main queue for the next item after a short delay
                setTimeout(playNextAnnouncement, 500);
                return; // End the sequence
            }

            // **Recursive Step: Play current language audio**
            const lang = publicAnnouncementLanguages[langIndex];
            // Construct the direct path to the public MP3 file
            const audioUrl = `/media/announcement/${lang}.mp3`; // Assumes files are served from /public/media/...
            console.log(`-> Playing PUBLIC cycle part ${langIndex + 1}/${publicAnnouncementLanguages.length}: ${lang} (${audioUrl})`);

            // Use the generic player; the lock remains TRUE until the base case above
            playAudioFromUrl(audioUrl,
                () => { // onEndCallback (Success): Called when this language finishes
                    console.log(`<- Finished PUBLIC cycle part OK: ${lang}.`);
                    playPublicCycleSequentially(langIndex + 1); // Play next language
                },
                () => { // onErrorCallback: Called when this language fails
                    console.error(`<- Finished PUBLIC cycle part ERROR: ${lang}. Skipping to next language.`);
                    playPublicCycleSequentially(langIndex + 1); // Try next language anyway
                }
            );
        }


        /**
         * Generic function to play audio from a given URL using the announcementAudio element.
         * It handles the play promise and sets up 'onended' and 'onerror' listeners.
         * IMPORTANT: It does NOT manage the global isPlayingAudio flag.
         * @param {string} url - The URL of the audio file or stream to play.
         * @param {function} onEndCallback - Function to call when playback finishes successfully.
         * @param {function} onErrorCallback - Function to call if playback encounters an error.
         */
        function playAudioFromUrl(url, onEndCallback, onErrorCallback) {
            // Simple wrappers just to ensure callbacks are called
            const successCallbackWrapper = () => { onEndCallback(); };
            const failureCallbackWrapper = () => { onErrorCallback(); };

            // Set source and load
            announcementAudio.src = url;
            announcementAudio.load();
            console.log(`   playAudioFromUrl: Attempting to play audio from: ${url}`);

            // Attempt to play, handle promise
            const playPromise = announcementAudio.play();
            if (playPromise !== undefined) {
                playPromise.then(() => {
                    // Playback started successfully
                    console.log(`   playAudioFromUrl: Playback started for: ${url}`);
                    // Setup listeners for completion or error during playback
                    announcementAudio.onended = () => {
                        console.log(`   playAudioFromUrl: Playback finished (onended event) for: ${url}`);
                        announcementAudio.onended = null; announcementAudio.onerror = null; // Cleanup
                        setTimeout(successCallbackWrapper, 50); // Callback after short delay
                    };
                    announcementAudio.onerror = (e) => {
                        console.error(`   playAudioFromUrl: Playback error during playback (onerror event) for ${url}:`, e);
                        announcementAudio.onended = null; announcementAudio.onerror = null; // Cleanup
                        setTimeout(failureCallbackWrapper, 50); // Callback after short delay
                    };
                }).catch(error => {
                    // Error initiating playback (e.g., browser restriction, invalid source)
                    console.error(`   playAudioFromUrl: Error initiating playback (play() rejected) for ${url}:`, error);
                    announcementAudio.onended = null; announcementAudio.onerror = null; // Cleanup
                    setTimeout(failureCallbackWrapper, 50); // Callback after short delay
                });
            }
            // Note: Fallback for browsers without promise support could be added here if needed
        }

        // Optional: General error listener on the audio element for loading issues etc.
        announcementAudio.addEventListener('error', (e) => {
            if (isPlayingAudio && announcementAudio.src && announcementAudio.networkState === announcementAudio.NETWORK_NO_SOURCE) {
                console.error("General Audio Element Error (e.g., loading failed, 404?):", e, "for src:", announcementAudio.src);
                // This might indicate a deeper issue, but the specific error handlers should ideally catch playback problems.
            }
        });

        // --- Initialization ---
        window.addEventListener('load', () => {
            // Calculate history size after layout stabilizes
            setTimeout(() => {
                calculateMaxHistory();
                if (historyRecalcIntervalId) clearInterval(historyRecalcIntervalId);
                historyRecalcIntervalId = setInterval(calculateMaxHistory, HISTORY_RECALC_INTERVAL_MS);
            }, 250);
            // Start listening for server events
            connectEventSource();
            // Add a click listener to unlock audio playback on mobile/strict browsers
            // This helps ensure audio can play when initiated by code later
            document.body.addEventListener('click', () => {
                chimeAudio.load();
                announcementAudio.load();
                console.log("User interaction detected. Audio elements loaded.");
            }, { once: true }); // Only run once
        });
        // Recalculate history size on window resize
        window.addEventListener('resize', calculateMaxHistory);
        // Cleanup resources when the page is closed
        window.addEventListener('beforeunload', () => {
            if (socket) socket.close();
            if (reconnectTimeoutId) clearTimeout(reconnectTimeoutId);
            if (historyRecalcIntervalId) clearInterval(historyRecalcIntervalId);
            // Stop any potentially playing audio
            chimeAudio.pause();
            announcementAudio.pause();
            announcementAudio.src = ""; // Clear source
        });

    </script>
</body>

</html>