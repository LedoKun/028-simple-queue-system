<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Queue TV Display</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="apple-touch-icon" sizes="180x180" href="/media/icons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/media/icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/media/icons/favicon-16x16.png">
    <link rel="manifest" href="/site.webmanifest">
    <link href="https://fonts.googleapis.com/css2?family=Battambang&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+Thai:wght@400;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@400;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">
    <style>
        /* CSS Styles */
        * {
            box-sizing: border-box;
        }

        html {
            height: 100%;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: #1a1a1a;
            color: #f0f0f0;
            font-family: 'Noto Sans Thai', 'Noto Sans SC', 'Noto Sans JP', 'Roboto', 'Battambang', Arial, sans-serif;
            display: flex;
            height: 100vh;
            width: 100vw;
            overflow: hidden;
            padding-bottom: 30px;
        }

        .container {
            display: flex;
            width: 100%;
            flex-grow: 1;
        }

        .current-queue-station {
            flex: 0 0 40%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            border-right: 2px solid #333;
            padding: 1em;
            min-height: 0;
        }

        .label {
            font-size: 2.5vw;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 0.1em;
            animation: fadeIn 0.5s ease-in-out;
            text-align: center;
        }

        .subtitle {
            font-size: 1.5vw;
            font-weight: normal;
            margin-bottom: 0.5em;
            color: #bbb;
            animation: fadeIn 0.5s ease-in-out 0.2s;
            font-family: 'Roboto', 'Battambang', Arial, sans-serif;
            text-align: center;
            line-height: 1.2;
        }

        .number-large {
            font-size: 12vw;
            font-weight: bold;
            color: #b19cd9;
            margin: 0.1em 0;
            animation: numberChange 0.8s ease-in-out;
            text-align: center;
            line-height: 1.1;
        }

        .history-section {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
            min-height: 0;
        }

        .history-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 2vw;
            text-align: center;
        }

        .history-table thead {
            background-color: #333;
            position: sticky;
            top: 0;
            z-index: 1;
        }

        .history-table th {
            padding: 0.4em 0.8em;
            border-bottom: 1px solid #444;
            font-weight: 600;
            text-transform: uppercase;
        }

        .history-table td {
            padding: 0.4em 0.8em;
            border-bottom: 1px solid #333;
            word-break: break-all;
            animation: rowFadeIn 0.5s ease-in-out;
        }

        .history-table tbody tr:nth-child(even) {
            background-color: #2a2a2a;
        }

        .history-table tbody tr:nth-child(odd) {
            background-color: #222;
        }

        .status-indicator {
            position: fixed;
            bottom: 5px;
            right: 10px;
            padding: 4px 12px;
            border-radius: 5px;
            font-size: 0.8em;
            font-weight: bold;
            z-index: 1000;
            color: #fff;
            transition: background-color 0.5s ease;
        }

        .status-connected {
            background-color: #28a745;
        }

        .status-disconnected {
            background-color: #dc3545;
        }

        .status-connecting {
            background-color: #ffc107;
            color: #333;
        }

        @media only screen and (max-width: 768px) {
            body {
                height: auto;
                min-height: 100vh;
                padding-bottom: 35px;
            }

            .container {
                flex-direction: column;
                height: auto;
            }

            .current-queue-station {
                flex: 0 0 auto;
                border-right: none;
                border-bottom: 2px solid #333;
                padding: 2em 1em;
            }

            .history-section {
                flex: 1 1 auto;
                overflow-y: auto;
                min-height: 200px;
                max-height: 50vh;
            }

            .label {
                font-size: 5vw;
            }

            .subtitle {
                font-size: 3vw;
            }

            .number-large {
                font-size: 15vw;
            }

            .history-table {
                font-size: 4vw;
            }

            .history-table thead {
                position: static;
            }

            .status-indicator {
                font-size: 1.5vw;
                padding: 6px 10px;
                bottom: 8px;
                right: 8px;
            }
        }

        @keyframes numberChange {
            from {
                opacity: 0.5;
                transform: scale(0.8);
            }

            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }

            to {
                opacity: 1;
            }
        }

        @keyframes rowFadeIn {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="current-queue-station">
            <div class="label">ช่อง/Station</div>
            <div class="subtitle">(ကောင်တာ/Quầy/Estasyon/窓口/窗口)</div>
            <div class="number-large" id="currentStation">-</div>

            <div class="label" style="margin-top: 0.5em;">คิว/Queue</div>
            <div class="subtitle">(လိုင်း/Số/Pila/番号/排队)</div>
            <div class="number-large" id="currentQueue">-</div>
        </div>
        <div class="history-section">
            <table class="history-table">
                <thead>
                    <tr>
                        <th>ช่อง/Station<br><span class="subtitle">(ကောင်တာ/Quầy/Estasyon/窓口/窗口)</span></th>
                        <th>คิว/Queue<br><span class="subtitle">(လိုင်း/Số/Pila/番号/排队)</span></th>
                    </tr>
                </thead>
                <tbody id="historyTable"></tbody>
            </table>
        </div>
    </div>

    <div id="serverStatus" class="status-indicator status-connecting">Connecting...</div>
    <audio id="chimeAudio" src="media/chime.mp3" preload="auto"></audio>
    <audio id="announcementAudio" preload="none"></audio>

    <script>
        const currentQueueEl = document.getElementById("currentQueue");
        const currentStationEl = document.getElementById("currentStation");
        const historyTableBody = document.getElementById("historyTable");
        const chimeAudio = document.getElementById("chimeAudio");
        const announcementAudio = document.getElementById("announcementAudio");
        const serverStatusEl = document.getElementById("serverStatus");

        let MAX_HISTORY = 10;
        let isPlayingAudio = false;
        const announcementQueue = [];
        const languagesToSpeak = ['th', 'en', 'my'];
        const publicAnnouncementLanguages = ['th', 'en', 'my'];
        const RECONNECT_DELAY_MS = 5000;
        const HISTORY_RECALC_INTERVAL_MS = 30000;
        let socket, reconnectTimeoutId = null, historyRecalcIntervalId = null;
        let previousQueue = null, previousStation = null;

        function updateServerStatus(status, message) {
            if (!serverStatusEl) return;
            serverStatusEl.textContent = message;
            serverStatusEl.classList.remove('status-connected', 'status-disconnected', 'status-connecting');
            if (status === 'connected') serverStatusEl.classList.add('status-connected');
            else if (status === 'disconnected') serverStatusEl.classList.add('status-disconnected');
            else serverStatusEl.classList.add('status-connecting');
            console.log(`UI: Server status updated to: ${status} - ${message}`);
        }

        function calculateMaxHistory() {
            try {
                const header = historyTableBody.previousElementSibling;
                const container = historyTableBody.closest('.history-section');
                const available = container.offsetHeight - (header ? header.offsetHeight : 0);
                if (historyTableBody.children.length > 0) {
                    const row = historyTableBody.children[0];
                    MAX_HISTORY = Math.max(1, Math.floor(available / row.offsetHeight));
                } else {
                    const base = window.innerWidth * ((window.matchMedia("only screen and (max-width: 768px)").matches ? 4 : 2) / 100);
                    const est = (0.4 * base) + (0.4 * base) + (1.3 * base) + 1;
                    MAX_HISTORY = Math.max(1, Math.floor(available / est));
                }
                trimHistory();
            } catch (e) { MAX_HISTORY = 10; trimHistory(); }
        }
        function trimHistory() { while (historyTableBody.children.length > MAX_HISTORY) historyTableBody.removeChild(historyTableBody.lastChild); }

        function connectEventSource() {
            if (reconnectTimeoutId) clearTimeout(reconnectTimeoutId);
            if (socket) socket.close();
            console.log("Attempting to connect to SSE (/events)...");
            updateServerStatus('connecting', 'Connecting...');
            socket = new EventSource("/events");
            socket.onopen = () => updateServerStatus('connected', 'Connected');
            socket.onmessage = event => {
                if (event.data.startsWith(': heartbeat')) return updateServerStatus('connected', 'Connected');
                try {
                    const d = JSON.parse(event.data);
                    if (d.type === 'public_announcement_cycle_start') { announcementQueue.push({ type: 'public_cycle' }); playNextAnnouncement(); }
                    else if (d.type === 'queue_call') { const { queue, station } = d.data; updateDisplay(queue, station); announcementQueue.push({ type: 'queue', data: { queue, station } }); playNextAnnouncement(); }
                } catch (e) { console.error("Error processing SSE:", e); }
            };
            socket.onerror = err => {
                console.error("SSE error:", err);
                updateServerStatus('disconnected', 'Disconnected');
                socket.close();
                if (!reconnectTimeoutId) { updateServerStatus('disconnected', 'Retrying...'); reconnectTimeoutId = setTimeout(connectEventSource, RECONNECT_DELAY_MS); }
            };
        }

        function updateDisplay(queue, station) {
            const q = String(queue), s = String(station);
            console.log(`updateDisplay called: New=${q}/${s}`);
            if (previousQueue !== null && previousQueue !== q) {
                const first = historyTableBody.firstChild;
                let add = true;
                if (first) { const c = first.getElementsByTagName('td'); if (c.length > 1 && c[1].textContent === previousQueue) add = false; }
                if (add) { const r = document.createElement('tr'); r.innerHTML = `<td>${previousStation}</td><td>${previousQueue}</td>`; historyTableBody.insertBefore(r, historyTableBody.firstChild); }
            }
            currentQueueEl.textContent = q; currentStationEl.textContent = s; resetAnimation(currentQueueEl); resetAnimation(currentStationEl);
            historyTableBody.querySelectorAll('tr').forEach(r => { const c = r.getElementsByTagName('td'); if (c.length >= 2 && c[1].textContent === q) r.remove(); });
            previousQueue = q; previousStation = s; trimHistory(); console.log("updateDisplay finished.");
        }
        function resetAnimation(el) { el.style.animation = 'none'; el.offsetHeight; el.style.animation = null; }

        function playNextAnnouncement() {
            if (isPlayingAudio || announcementQueue.length === 0) return; isPlayingAudio = true; const item = announcementQueue.shift();
            chimeAudio.currentTime = 0; const p = chimeAudio.play().catch(() => new Promise(r => setTimeout(r, 100)));
            p.then(() => {
                const cont = () => {
                    chimeAudio.onended = null;
                    if (item.type === 'queue') playQueueSeq(item.data, 0);
                    else if (item.type === 'public_cycle') playPubSeq(0);
                    else { console.error("Unknown type."); isPlayingAudio = false; setTimeout(playNextAnnouncement, 100); }
                };
                chimeAudio.onended = cont; if (chimeAudio.paused || chimeAudio.ended) cont();
            });
        }
        function playQueueSeq(d, i) { if (i >= languagesToSpeak.length) { isPlayingAudio = false; setTimeout(playNextAnnouncement, 500); return; } const lang = languagesToSpeak[i]; playAudio(`/speak?queue=${encodeURIComponent(d.queue)}&station=${encodeURIComponent(d.station)}&lang=${encodeURIComponent(lang)}`, () => playQueueSeq(d, i + 1), () => playQueueSeq(d, i + 1)); }
        function playPubSeq(i) { if (i >= publicAnnouncementLanguages.length) { isPlayingAudio = false; setTimeout(playNextAnnouncement, 500); return; } const lang = publicAnnouncementLanguages[i]; playAudio(`/media/announcement/${lang}.mp3`, () => playPubSeq(i + 1), () => playPubSeq(i + 1)); }
        function playAudio(url, ok, err) { announcementAudio.src = url; announcementAudio.load(); const pr = announcementAudio.play(); if (pr) { pr.then(() => { announcementAudio.onended = () => { announcementAudio.onended = null; setTimeout(ok, 50); }; announcementAudio.onerror = () => { announcementAudio.onerror = null; setTimeout(err, 50); }; }).catch(() => { setTimeout(err, 50); }); } }

        window.addEventListener('load', () => { setTimeout(() => { calculateMaxHistory(); if (historyRecalcIntervalId) clearInterval(historyRecalcIntervalId); historyRecalcIntervalId = setInterval(calculateMaxHistory, HISTORY_RECALC_INTERVAL_MS); }, 250); connectEventSource(); document.body.addEventListener('click', () => { chimeAudio.load(); announcementAudio.load(); console.log("Audio elements loaded."); }, { once: true }); });
        window.addEventListener('resize', calculateMaxHistory);
        window.addEventListener('beforeunload', () => { if (socket) socket.close(); if (reconnectTimeoutId) clearTimeout(reconnectTimeoutId); if (historyRecalcIntervalId) clearInterval(historyRecalcIntervalId); chimeAudio.pause(); announcementAudio.pause(); announcementAudio.src = ""; updateServerStatus('disconnected', 'Disconnected'); });
    </script>
</body>

</html>